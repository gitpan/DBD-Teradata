<html><body>
<h2>NAME</h2><p>
<h3>
DBD::Teradata Lite - Perl DBI Driver for Teradata</h3><p>

<font size='-1'>
<ul>
<li><a href="#synopsis">SYNOPSIS</a>
<li><a href="#description">DESCRIPTION</a>
<li><a href="#version">VERSION</a>
<li><a href="#history">CHANGE HISTORY</a>
<li><a href="#behavior">DRIVER-SPECIFIC BEHAVIOR</a>
<ul>
<li><a href="#dsn">DATA-SOURCE NAME</a>
<li><a href="#cst">CONNECTIONS, SESSIONS AND TRANSACTIONS</a>
<li><a href="#types">DATA TYPES</a>
<li><a href="#parmsql">PARAMETERIZED SQL</a>
<li><a href="#mstmts">MULTI-STATEMENT AND MACRO REQUESTS</a>
<li><a href="#sumsel">SUMMARIZED SELECT REQUESTS</a>
<li><a href="#dblbuf">DOUBLE BUFFERING</a>
<li><a href="#errors">ERROR HANDLING</a>
<li><a href="#diags">DIAGNOSTICS</a>
<li><a href="#specattr">DRIVER-SPECIFIC ATTRIBUTES</a>
<ul>
<li><a href="#raw">tdat_raw</a>
<li><a href="#stnum">tdat_stmt_num</a>
<li><a href="#stinfo">tdat_stmt_info</a>
<li><a href="#ttlfmt">tdat_TITLE, tdat_FORMAT</a>
<li><a href="#keepresp">tdat_keepresp</a>
</ul>
<li><a href="#funcs">DRIVER-SPECIFIC FUNCTIONS</a>
<ul>
<li><a href="#bindcary">BindColArray</a>
<li><a href="#first">FirstAvailable</a>
<li><a href="#firstlist">FirstAvailList</a>
<li><a href="#realize">Realize</a>
</ul>
</ul>
<li><a href="#conform">CONFORMANCE</a>
<li><a href="#platforms">SUPPORTED PLATFORMS</a>
<li><a href="#tips">TIPS & TRICKS</a>
<li><a href="#refs">REFERENCES</a>
<li><a href="#copy">COPYRIGHT</a>
</ul><p>
<i>Last updated September 27, 2004</i><p>
</font>
<p>
<a name="synopsis"></a>
<h2>SYNOPSIS</h2><p>
<pre>

     use DBI;
     my $dbh = DBI->connect(
          "dbi:Teradata:some.host.com",
          "user",
          "passwd")
          or die "Cannot connect\n";
     # more DBI calls...
</pre><p>
<a name="description"></a>
<h2>DESCRIPTION</h2><p>

'Lite' version of the Perl DBI driver for Teradata
(See <a href='http://dbi.perl.org'>DBI</a> for details).<br>

<b>BE ADVISED:</b> This is a 'Lite' version of the driver, provided with
limited functionality and maintenance, and subject to change at the whim of
the author. While every effort has been made to assure conformance to
DBI-1.13, some peculiarities of Teradata may not be 100% compatible.
In addition, some niceties of Teradata not found in DBI have been included
to make this library useful for common Teradata tasks (MACRO and multistatement
request support, support for summary rows, etc.). Look
<a href="http://www.presicient.com/tdatdbd.html">here</a>
for information regarding the fully functional and maintained version.<p>
This driver is 100% pure Perl, and requires <b>no</b> CLI, ODBC, or other
interface libraries, other than
<ul>
<li>the standard DBI package
<li>Crypt::Blowfish OR Crypt::Blowfish_PP (for encryption support)
<li>Math::BigInt (a CORE module as of Perl 5.8)
</ul>
<p>
<b>NOTE:</b>Due to numerous functional issues, PM/API, FASTLOAD, and EXPORT
connection support have been removed from this "lite" version.
The commercial version available at
<a href='http://www.presicient.com/tdatdbd'>www.presicient.com</a>
retains that functionality, as well as supporting:

<ul>
<li>MLOAD
<li>remote console
<li>UTF8 (UNICODE)
<li>Perl threads
<li>an optional CLI library adapter
<li>ANSI mode
<li>Updatable cursors
<li>stored procedures
<li>large SQL requests
<li>Formatted results
<li>numerous other minor features
<li>numerous bugfixes
<li>significant performance improvement
</ul>
<p>

<a name="version"></a>
<h2>CURRENT VERSION</h2><p>

Release 1.20<p>
<a name="history"></a>
<h2>CHANGE HISTORY</h2><p>

Release 1.20<p>
<ul>
<li>added R5.1 logon encryption support
<li>removed non-SQL connection support
<li>clarified license text
</ul><p>

Release 1.13:<p>
<ul>
<li>updated contact info
</ul><p>

<a name="behavior"></a>
<h2>DRIVER-SPECIFIC BEHAVIOR</h2><p>
<a name="dsn"></a>
<h3>DATA-SOURCE NAME</h3><p>

The dsn string passed to <code>DBI-&gt;connect()</code> must be of the following form:<p>
<pre>
     dbi:Teradata:host[:port]
</pre><p>

where
<ul>
<li><b>host</b> is a TCP/IP address in human-readable or dotted-decimal format,
<li><b>port</b> is an optional TCP/IP port number to use (default is 1025,
the most common value),
</ul><p>
Note that this driver will <b>NOT</B> perform the random
selection algorithm for resolving the hostname(via the
"hostnameCOPN" convention)  when multiple paths are available.
You should either use the
full explicit hostname (e.g., "DBCCOP1"), the numeric IP address (e.g.,
"1.2.3.4"), create an alias for the explicit hostname, or, better still,
use <b>bind(3)</b> the way God intended.<p>
<a name="cst"></a>
<h3>CONNECTIONS, SESSIONS AND TRANSACTIONS</h3><p>

Multiple connections (aka sessions) to a Teradata database are supported.
<p>

This Lite version of the driver supports only Teradata mode (i.e., *not* ANSI mode).
That means that DDL statements and multistatement requests implicitly finish a transaction,
and AUTOCOMMIT is the default. We don't flag any non-ANSI SQL, either.
See the <a href="http://www.info.ncr.com">Teradata SQL documents</a>
for all the differences between ANSI and Teradata behavior.
The commercial version does support ANSI mode.<p>

RunStartup execution is not supported.<p>

Cursor SQL syntax (i.e., <code>...WHERE CURRENT OF...</code>) is not supported
in this Lite version, but is supported in the commercial version.<p>

Session reconnection is not supported.<p>

Teradata account strings can be provided by simply appending a
single comma, followed by the single-quoted account string,
to the password string, e.g.,<br>
<pre>
     use DBI;
     my $dbh = DBI->connect(
          "dbi:Teradata:some.host.com",
          "user",
          "passwd,'\$H&Lmyaccount'")
          or die "Cannot connect\n";
     # more DBI calls...
</pre>

HELP statements are not supported, due to an apparent bug in the data returned by the DBMS in
RECORD mode.<p>

<a name="types"></a>
<h3>DATA TYPES</h3><p>

The following list maps DBI defined data types to their Teradata
equivalent (if applicable):<p>

<table border=1>
<tr><td align=center><b>DBI<br>Data Type</td><td align=center><b>Teradata<br>Data Type</td></tr>
<tr><td align=center> SQL_CHAR	</td><td align=center>CHAR</td></tr>
<tr><td align=center> SQL_NUMERIC </td><td align=center>DECIMAL</td></tr>
<tr><td align=center> SQL_DECIMAL </td><td align=center>DECIMAL</td></tr>
<tr><td align=center> SQL_INTEGER </td><td align=center>INTEGER</td></tr>
<tr><td align=center> SQL_SMALLINT	</td><td align=center>SMALLINT</td></tr>
<tr><td align=center> SQL_FLOAT </td><td align=center>FLOAT</td></tr>
<tr><td align=center> SQL_REAL </td><td align=center>FLOAT</td></tr>
<tr><td align=center> SQL_DOUBLE </td><td align=center>FLOAT</td></tr>
<tr><td align=center> SQL_VARCHAR	</td><td align=center>VARCHAR</td></tr>
<tr><td align=center> SQL_DATE </td><td align=center>DATE</td></tr>
<tr><td align=center> SQL_TIME </td><td align=center>TIME</td></tr>
<tr><td align=center> SQL_TIMESTAMP	</td><td align=center>TIMESTAMP</td></tr>
<tr><td align=center> SQL_LONGVARCHAR </td><td align=center>LONG VARCHAR</td></tr>
<tr><td align=center> SQL_BINARY </td><td align=center>BYTE</td></tr>
<tr><td align=center> SQL_VARBINARY </td><td align=center>VARBYTE</td></tr>
<tr><td align=center> SQL_LONGVARBINARY	</td><td align=center>LONG VARBYTE</td></tr>
<tr><td align=center> SQL_BIGINT </td><td align=center>	N/A</td></tr>
<tr><td align=center> SQL_TINYINT	</td><td align=center>BYTEINT</td></tr>
<tr><td align=center> SQL_WCHAR </td><td align=center>N/A</td></tr>
<tr><td align=center> SQL_WVARCHAR </td><td align=center>N/A </td></tr>
<tr><td align=center> SQL_WLONGVARCHAR </td><td align=center>N/A</td></tr>
<tr><td align=center> SQL_BIT </td><td align=center>N/A</td></tr>
</table><p>

NOTE: INTERVAL types are not yet supported.<p>

<b>CAUTION:</B> Floating point and DECIMAL support within the Teradata DBMS requires
specific knowledge of the client platform. Platforms this driver
currently knows about are:<p>

<ul>
<li>Intel X86 (or equivalent processor types)
<li>Sun SPARC, Motorola 68XXX, PowerPC, HP PA-RISC, and similar processors
</ul><p>

This driver attempts to auto-detect the platform on which it is running as
follows:<p>

<table border=1><tr>
<td align=center><b>Character<br>Set</td><td align=center><b>Integer format</td><td align=center><b>Assumed<br>Platform</td></tr>
<td align=center>ASCII</td><td align=center>not network-order<br>(MSB last)</td><td align=center>Intel</td></tr>
<td align=center>ASCII</td><td align=center>network-order<br>(MSB first)</td><td align=center>SPARC/MOTOROLA</td></tr>
</table>
<p>
Autodetection can be overridden by setting the environment variable
<code>TDAT_PLATFORM_CODE</code> to the appropriate platform code:<p>

<table border=1><tr><td align=center><b>Platform</b></td><td align=center><b>TDAT_PLATFORM_CODE<br>Value</b></td></tr>
<tr><td align=center>Any Intel X86/Pentium</td><td align=center>8</td></tr>
<tr><td align=center> Sun SPARC,<br>Motorola 68XXX,<br>ATT 3b2</td><td align=center>7</td></tr>
<tr><td align=center> VAX</td><td align=center>9</td></tr>
<tr><td align=center> IBM 370/390</td><td align=center>3</td></tr>
<tr><td align=center> AMDAHL UTS</td><td align=center>10</td></tr>
<tr><td align=center> Honeywell</td><td align=center>4</td></tr>
</tr></table><p>

If your platform's floating point (specifically, double-precision) format
does not match that of one of those platforms, <b>AVOID FLOATING POINT VALUES!</b>
Substituting DECIMAL or CHARACTER values will often work well, though
loss of precision may be a problem.<p>

For some platforms (notably VAXen and mainframes), Teradata returns
DECIMALs as binary-coded decimal (BCD) values. For most workstation
platforms (Intel and most RISC), DECIMAL is returned as a simple
fix-point integer. Currently, DBD::Teradata only converts the latter
format. BCD encoded values may eventually be supported if sufficient
hue and cry is raised...but it's currently not a priority.<p>

Finally, note that double-byte character sets (i.e, UNICODE, Kanji, etc.) are not
supported in this Lite version, but are supported (via UTF8) in the commercial
version<p>

<a name="parmsql"></a>
<h3>PARAMETERIZED SQL</h3><p>
This driver supports both <code>USING</code> clauses and placeholders
to implement parameterized SQL; however, they cannot be mixed
in the same request. Also, when using placeholders, all parameter
datatypes are assumed to be <code>VARCHAR(16)</code> unless explicit
datatypes are specified via a bind_param() call, or the environment
variable TDAT_PH_SIZE has been defined to another value. However,
the driver <b>will</B> adjust the parameter type declaration provided to the
DBMS upon <code>execute()</code> so that parameters without explicit type
specifications which exceed the <code>VARCHAR(16)</code> size, will be
presented to the DBMS as <code>VARCHAR(&lt;actual-param-length&gt;)</code>.<p>

<a name="mstmts"></a>
<h3>MULTI-STATEMENT AND MACRO REQUESTS</h3><p>
Multi-statement and MACRO execution requests are supported. Stored procedure
support is available in the commercial version of this driver.<p>

Reporting the results of multi-statement and MACRO requests presents some special
problems. Refer to the <a href="#specattr"><b>DRIVER SPECIFIC ATTRIBUTES</b></a> section
below for detailed descriptions
of relevant statement handle attributes. The driver behavior is augmented as follows:

<ul>
<li>All DBI statements will have an associated <code>tdat_stmt_info</code>
statement handle attribute. (Note that DBI's notion of a statement is equivalent to
a Teradata <b><i>request, which may contain more than 1 SQL statement</i></b>. For the
purposes of this discussion, the Teradata definitions of request and statement will be
used; when refering to DBI's definition of a statement, the term "DBI statement" will
be used).
<code>tdat_stmt_info</code> returns an arrayref of hashrefs. Each array entry
is indexed by its associated statement number within a Teradata request. <b>Please note
that the DBMS starts statement numbering with 1, not zero; thus, loop constructs
used to scan the statement info array should start their index values at 1.</b>
The hashref has several keys, described in the following sections and in the
<a href="#specattr"><b>DRIVER-SPECIFIC ATTRIBUTES</b></a> section.<p>

<li>For multi-statement and MACRO requests which do not return rows (i.e.,
do not include SELECT statements), the <code>fetchrow_XXX()</code> statement
handle method will always return an empty string result. The activity type,
activity count, and warning message of an individual statement
can be queried via the <code>ActivityType</code>, <code>ActivityCount</code> and
<code>Warning</code> keys in the statement's hashref in the array returned by the
<code>tdat_stmt_info</code> attribute.<p>

<li>Multi-statement and MACRO requests which include a single SELECT statement
are handled exactly like a single SELECT statement.
Note that if any non-SELECT statements
sequentially follow the SELECT statement, their attributes should not be queried
until all SELECTed rows have been fetched, since the results of the succeding statements
are not reported by the DBMS until all the rows have been returned.<p>

<li>Multi-statement and MACRO requests which include multiple SELECT statements
require special handling when fetching results. The <code>tdat_stmt_info</code>
attributes still apply as for single-SELECT multi-statement or MACRO requests. However, the
column (and summary) information for <b><i>all</i></b> SELECT statements are included in the
<b><code>NAME, TYPE, PRECISION, SCALE, </b>and<b> NULLABLE</code></b> DBI statement handle
attributes, and each fetched row will include fields for <b><i>all</i></b>
SELECT statements, but only the fields for the current SELECT
statement will be be valid. All fields for non-current SELECT will be set to
<b><code>undef</code></b> (<i>not unlike the results of an OUTER JOIN</i>).
In order to identify the SELECT statement that a <code>fetchrow_XXX()</code> call
is processing:
<ul>
<li>the <code>tdat_stmt_num</code> attribute can be queried to get the
current statement number

<li>the starting index of column information for the current statement
can be retrieved via the key <b><code>StartsAt</code></b> in the hashref
located at the current statement's index in the array returned by the
<code>tdat_stmt_info</code> attribute.

<li>the ending index of column information for the current statement
can be retrieved via the key <b><code>EndsAt</code></b> in the hashref
located at the current statement's index in the array returned by the
<code>tdat_stmt_info</code> attribute.

</ul>
</ul>
<p>
An example of processing multi-SELECT requests:<p>
<pre>

$sth = $dbh->prepare('SELECT user; SELECT date; SELECT time;');
$names = $sth->{NAME};
$types= $sth->{TYPE};
$precisions = $sth->{PRECISION};
$scales = $sth->{SCALE};
$stmt_info = $sth->{'tdat_stmt_info'};

$sth->execute();
$currstmt = -1;
while ($rows = $sth->fetch_array()) {
	if ($currstmt != $sth->{'tdat_stmt_num'}) {
		print "\n\n";
		$currstmt = $sth->{'tdat_stmt_num'};
		$stmthash = $$stmt_info[$currstmt};
		$starts_at = $$stmthash{'StartsAt'};
		$ends_at = $$stmthash{'EndsAt'};
		for ($i = $starts_at; $i &lt;= $ends_at; $i++) {
			print "$$names[$i] ";
		}
		print "\n";
	}
	for ($i = $starts_at; $i &lt;= $ends_at; $i++) {
		print "$row[$i] ";
	}
}

</pre>
<p>

<a name="sumsel"></a>
<h3>SUMMARIZED SELECT REQUESTS</h3><p>
Like multi-statement and MACRO requests, reporting the results of
summarized SELECT requests requires some special processing. Refer to the
<a href="#specattr"><b>DRIVER SPECIFIC ATTRIBUTES</b></a> section
below for detailed descriptions
of relevant statement handle attributes. The driver behavior is augmented as follows:
<ul>
<li>Like multi-SELECT statement requests, summarized SELECT statements will include <b>all</b>
summary columns in the DBI attribute and row data arrays. The summary columns in the rowdata
array returned by <code>fetchrow_XXX()</code> will be set to <code>undef</code> until a
summary row is returned by the DBMS.

<li>When a summary row is fetched, an <code><b>IsSummary</b></code> attribute of the
current statment hashref (stored at the current statement number index within the arrayref returned
by the <code>tdat_stmt_info</code> statement handle attribute) returns the summary row
number of the current statement; otherwise, it will be set to <code>undef</code>.

<li>the current statement hashref also includes <b><code>SummaryStarts</code></b> and
<b><code>SummaryEnds</code></b> attributes,
which return arrays (indexed by summary row number) of starting and ending indexes, respectively,
within the DBI attribute and row data arrays for each summary row
(You're probably confused at this point, so review the
<a href="#sumeg">example</a> below).

<li>the current statement hashref includes a <b><code>SummaryPosition</code></b> attribute,
which returns an arrayref of the column numbers associated with each summary field
within the current statement. <b>NOTE:</b> SummaryPosition information is not available
until after the execute() method has been called and a summary row has been fetched.

<li>the current statement hashref includes a <b><code>SummaryPosStart</code></b> attribute,
which returns an arrayref, indexed by summary row number, of the starting index within the
<b><code>SummaryPosition</code></b> array for the current summary row.
<b>NOTE:</b> SummaryPosStart information is not available
until after the execute() method has been called and a summary row has been fetched.
</ul><p>
<a name="sumeg"></a>
An example of processing summarized SELECT:<p>
<pre>

$sth = $dbh->prepare('SELECT Name FROM Employees WITH AVG(Salary), SUM(Salary)');
$names = $sth->{NAME};
$types= $sth->{TYPE};
$precisions = $sth->{PRECISION};
$scales = $sth->{SCALE};
$stmt_info = $sth->{'tdat_stmt_info'};

$sth->execute();
$currstmt = -1;
while ($rows = $sth->fetchrow_array()) {
	if ($currstmt != $sth->{'tdat_stmt_num'}) {
#
#	new stmt, get its info
#
		print "\n\n";
		$currstmt = $sth->{'tdat_stmt_num'};
		$stmthash = $$stmt_info[$currstmt];
		$starts_at = $$stmthash{'StartsAt'};
		$ends_at = $$stmthash{'EndsAt'};
		$sumstarts = $$stmthash{'SummaryStarts'};
		$sumends = $$stmthash{'SummaryEnds'};
		$sumrow = $$stmthash{'IsSummary'};
		for ($i = $starts_at; $i &lt;= $ends_at; $i++) {
			print "$$names[$i] ";	# print the column names
		}
		print "\n";
	}
	if (defined($sumrow)) {
#
#	got a summary row, space it
#	NOTE: this example uses simple tabs to space summary fields;
#	in practice, a more rigorous method to precisely align summaries with their
#	respective columns would be used
#
		$sumpos = $$stmthash{'SummaryPosition'};
		$sumposst = $$stmthash{'SummaryPosStart'};
		print "\n-----------------------------------------------------\n";
		for ($i = $$sumstart[$sumrow], $j = $$sumposst[$sumrow];
			$i &lt;= $$sumend[$sumrow]; $i++, $j++) {
			print ("\t" x $$sumpos[$j]);	# tab each column for alignment
			print "$$names[$i]: $row[$i]\n";
		}
	}
	else {
#
#	regular row, just print the values
#
		for ($i = $starts_at; $i &lt;= $ends_at; $i++) {
			print "$row[$i] ";
	}
}

</pre>
<p>

<a name="utilsupp"></a>
<h3>UTILITY SUPPORT</h3><p>
<i>Support for non-SQL connections has been removed from this version
due to numerous bugs and functional limitations. The commercial
version provides much improved support for these features, as well
as adding multiload and remote console support.</i>
<p>
<a name="dblbuf"></a>
<h3>DOUBLE BUFFERING</h3><p>

Double buffering (i.e., issuing a CONTINUE to the DBMS while the
application is still fetching data from the last received set of rowdata)
is supported, but not yet thoroughly tested. Use at your own risk by
defining an environment variable <b><code>TDAT_NO2BUFS=0</code></b>.<p>

<a name="errors"></a>
<h3>ERROR HANDLING</h3><p>

DBI does not support the notion of warnings;
therefore, the hashref provided by the driver specific statement handle attribute
<code>tdat_stmt_info</code> provides a <code>Warning</code> attribute that
can be queried to retrieve warning messages.
<p>

<a name="diags"></a>
<h3>DIAGNOSTICS</h3><p>

DBI provides the <code>trace()</code> function to enable various levels
of trace information. DBD::Teradata uses this trace level to report
its internal operation, as well.<p>

<ul>
<li>If the trace level is unset, or set to zero, no diagnostic reporting
is performed.
<li>If trace level is set to 1, some limited diagnostic reporting is
performed. This trace level is useful for informational (as opposed to
debugging) purposes.
<li>If trace level is set to 2 or higher, detailed level diagnostic
reporting is performed. Hex dumps of sent and received parcel
streams and message headers will be included if an environment
variable TDAT_DBD_DEBUG is set to a non-zero value.
This level should be used
whenever a potential driver bug is believed to exist, and
the resulting report should be included when the bug is reported
(assuming the data stream doesn't include sensitive information).
<b>PLEASE DON'T SEND DIAGNOSTIC DUMPS THAT INCLUDE CONFIDENTIAL
OR SENSITIVE INFORMATION!!</b> Instead, try to reproduce the problem
using dummy data.
</ul>

<a name="specattr"></a>
<h3> DRIVER-SPECIFIC ATTRIBUTES</h3><p>
There are some additional attributes that the user can either supply to
various DBI calls, or query on database or statement handles:<p>

<ul>
<a name="raw"></a>
<li> tdat_raw<p>
<i>Write-only on statement handle creation; read-only on statement handle thereafter.</i><br>
When set to either <code>RecordMode</code> or <code>IndicatorMode</code> in the attributes hash provided to a
<code>$dbh-&lt;prepare()</code>
call, causes the resulting DBI statement handle to either provide the output rowdata, or
accept the input parameter data, in Teradata binary import/export format (i.e., <br>
<code>&lt;2 byte length&gt;&lt;(optional) N bytes of indicators&gt;&lt;N bytes of data&gt;&lt;newline&gt;</code>).
Specifying <code><b>RecordMode</b></code> indicates data is provided without the NULL indicator
bits; <code><b>IndicatorMode</b></code> indicates data is provided with indicator bits.<p>

In raw input format,
each row of parameter data should be bound as SQL_VARBINARY type; in raw
output format, the row data will be returned as a single SQL_VARBINARY
result column. This attribute is
intended to provide a faster path for import/export pipelines
by avoiding the translation to/from internal Perl datatypes. E.g.,<p>
<pre>
open (FLIMPORT, 'fload.data') || die 'Can't open import data file: $!\n";

$sth = $dbh->prepare('USING (col1 integer, col2 char(20), col3 float, col4 varchar(100)) '
	. 'INSERT INTO MyTable VALUES(:col1, :col2, :col3, :col4);',
	{ 'tdat_raw' => 'IndicatorMode' });

while (sysread(FLIMPORT, $len, 2)) {
	sysread(FLIMPORT, $buffer, $len+1);	# remember the newline!
	$buffer = pack("SA*", $len, $buffer);
	$sth->bind_param(1, $buffer, {
		TYPE =&gt; SQL_VARBINARY,
		PRECISION =&gt; length($buffer)
	});
	$sth->execute( $buffer );
}
</pre>

<a name="stnum"></a>
<li>tdat_stmt_num<p>

<i>Read-only on statement handle.</i><br>
Returns the number of the current statement within the request associated with
the statement handle. Applies only for the <code>fetchrow_XXX()</code> statement
handle method; for requests which do not include SELECT statements, the returned
value is the total number of statements executed by the request.<p>

<a name="stinfo"></a>
<li>tdat_stmt_info<p>

<i>Read-only on statement handle.</i><br>
Returns an arrayref of hashrefs of Teradata statement information for each Teradata statement
within the request associated with the DBI statement handle. Not valid on EXPORT or PM/PC sessions.<br>
<b>Please note
that the DBMS starts statement numbering with 1, not zero; thus, loop constructs
used to scan the statement info array should start their index values at 1.</b>
The following attributes are included in each statement's hashref:<p>
<ul>
<li><code><b>ActivityType</b></code> - indicates the type of activity ('Select', 'Insert', 'Update', etc.)
of the statement.

<li><code><b>ActivityCount</b></code> - indicates the number of rows effected by the statement.

<li><code><b>Warning</b></code> - indicates any warning message associated with the statement. Returns
<code>undef</code> if none.

<li><code><b>StartsAt</b></code> - returns the starting index of a statement's returned column info or
data within the DBI column info and data arrays
(<code><b>NAME</b></code>, <code><b>PRECISION</b></code>, etc., as well as the results
of <code>fetchrow_XXX()</code>).
Each attribute and rowdata array includes entries for all columns of all SELECT statements
within a request. In order to isolate the array entries which apply to the statement
currently being fetched from, use the result of <code>$sth->{'tdat_stmt_num'}</code>
to index into the information and data arrayref's. See the
<a href="#mstmts"><b>MULTI-STATEMENT AND MACRO REQUESTS</b></a>
section above for details. For non-SELECT statements, <code>undef</code> is returned.

<li><code><b>EndsAt</b></code> - returns the (inclusive) ending index of a statement's
returned column attribute and data within the DBI attribute and row data arrays.
This does NOT include any summary columns information generated by the statement.
For non-SELECT statements, <code>undef</code> is returned.

<li><code><b>IsSummary</b></code> - returns the current summary
row number for the statement, if any, or <code>undef</code> if not a summarized SELECT
statement, or if the current row is not a summary row. The returned value is used to index
into the arrays returned by <code><b>SummaryStarts</b></code> and <code><b>SummaryEnds</b></code>
to locate the field values and attributes for the specified summary row.

<li><code><b>SummaryPosition</b></code> - returns an arrayref of the column numbers
associated with the summary fields in each summary row.
Set to <code>undef</code> for non-SELECT or non-summarized statements. SummaryPosition
information is not available until after the execute() method has been called and a
summary row has been fetched.

<li><code><b>SummaryPosStart</b></code> - returns an arrayref, indexed by summary row number,
of the starting index within the <code><b>SummaryPosition</b></code> array for each summary row.
Set to <code>undef</code> for non-SELECT or non-summarized statements. SummaryPosStart
information is not available until after the execute() method has been called and a
summary row has been fetched.

<li><code><b>SummaryStarts</b></code> - returns an array of starting indexes within the DBI
attribute and row data arrays for a statement's summary column info and data. Set to <code>undef</code>
for non-SELECT or non-summarized statements. When processing a summarized statement,
an application
<ul>
<li>retrieves the current statement's hashref from the arrayref returned by the
<code>tdat_stmt_info</code> statement handle attribute
<li>checks the <code>IsSummary</code> attribute of the current statement hashref
<li>retrieves the <code>SummaryStarts</code> and <code>SummaryEnds</code> arrays from the
current statement hashref
<li>uses the current summary row number (from the <code>IsSummary</code> attribute) to
get the starting and ending indexes (inclusive) of column attribute and row data
from the <code>SummaryStarts</code> and <code>SummaryEnds</code> arrays
<li>iterates through the DBI attribute and row data arrays using the retrieved start and end
indexes.
</ul>
Refer to the <a href="#sumeg">example</a> above for a better understanding of the
summary attribute structure.
<li><code><b>SummaryEnds</b></code> - returns an array of ending indexes within the DBI
attribute and row data arrays for a statement's summary column info and data.
Set to <code>undef</code> for non-SELECT or non-summarized statements.
</ul>

An example use of these attributes:<p>
<pre>
$sth = $dbh->prepare("INSERT INTO table VALUES(?,?,?,?); "
. "UPDATE table2 SET col1 = 'another value' WHERE col1 = 'some value';");

$rows = $sth->execute(1, 2, 3, 4);
$stmtcnt = $sth->{'tdat_stmt_num'};	# no SELECT, so returns number of last stmt
$stmt_info = $sth->{'tdat_stmt_info'};
for ($i = 0; $i &lt; $stmtcnt; $i++) {
	$stmthash = $$stmt_info[$i];
	$activity = $$stmthash{'ActivityType'};
	$stmtrows = $$stmthash{'ActivityCount'};
	$warn = $$stmthash{'Warning'};
	if ($warn) {
		print "Statement $i: $warn\n";
	}
	print "$activity at statement $i effected $stmtrows rows.\n";
}
</pre></li><p>

<a name="ttlfmt"></a>
<li> tdat_TITLE, tdat_FORMAT<p>
<i>Read-only on statement handle.</i><br>
Returns arrayref's of field title and format information (e.g., from (TITLE...) and (FORMAT ...)
clauses on SELECT or table/view specifications), ala the NAME, TYPE, PRECISION, etc. attributes.</li><p>

<a name="funcs"></a>
<h3> DRIVER-SPECIFIC FUNCTIONS</h3><p>

<ul>
<a name="bindpary"></a>
<li><code>$i = $sth->func(@param_list, BindParamArray);</code><p>
<i>This function has been removed, since it was only usable
for Fastload connections. For SQL connections, use the DBI standard
execute_array() and bind_param_array() functions.</i>
</li><p>

<a name="bindcary"></a>
<li><code>$i = $sth->func(@param_list, BindColArray);</code><p>

$param_list[0] is the number of the column to be bound, $param_list[1] is an arrayref
that will receive the column values, and $param_list[2] is the maximum number of rows the
application expects to be returned per fetch().<br>
This function allows a single fetch() operation to return multiple rows of data.
</li></ul><p>
In order to make this driver useful for high-performance ETL
applications, support for multiple concurrent sessions is needed.
Unfortunately, native DBI doesn't currently support the type
of asynchronous session interaction needed to efficiently
move data to/from a MPP database system. (Note that the
commercial version of this driver supports Perl threads,
which reduces the need for this type of asynchronous operation)
To address this need, the following functions have been provided:<p>
<ul>
<a name="first"></a>
<li><code>$i = $drh->func(@param_list, FirstAvailable);</code><p>

$param_list[0] is an arrayref of database handles, and $param_list[1] is a timeout specification
(in seconds, -1 or undef indicate infinite wait). Returns the index of the first session
within the supplied database handle array that is ready to be serviced. If none of the
sessions is ready for service, it waits up to the timeout
number of seconds (or forever if timeout is -1 or undef) for a session
to become ready. Returns <code>undef</code> if no sessions are ready in the specified timeout.</li><p>

<a name="firstlist"></a>
<li><code>@ary = $drh->func(@param_list, FirstAvailList);</code><p>

$param_list[0] is an arrayref of database handles, and $param_list[1] is a timeout specification
(in seconds, -1 or undef indicate infinite wait). Returns an array of indexes of sessions
within the supplied database handle array that are ready to be serviced. If none of the
sessions is ready for service, it waits up to the timeout
number of seconds (or forever if timeout is -1 or undef) for a session
to become ready. Returns <code>undef</code> if no sessions are ready in the specified timeout.<br>
NOTE: This function is useful for more evenly distriubting the workload across multiple
sessions when all sessions respond at nearly the same time. Using FirstAvailable() in that
situation tends to favor the first 1 or 2 sessions in the list, thus underusing the remaining
sessions.</li><p>

<a name="realize"></a>
<li><code>$i = $sth->func(undef, Realize);</code><p>

Realizes the results of a non-blocking statement execution. <code>FirstAvailable</code> and
<code>FirstAvailList</code>
only wait for and report that a session is ready; they do <b>not</b> process the results
on the session. <code>Realize</code> performs the actual processing of the database
response, including returning the success or failure of the operation, and any returned
rows.</li>
</ul><p>
NOTE: some platforms (notably Windows 95 and 98) may limit the total number of TCP/IP connections
which you can initiate.<p>
An example use of these functions to bulkload a table:<p>
<pre>
my $drh;
my @dbhlist;
my @sthlist;
open(IMPORT "$infile") || die "Can't open import file";
binmode IMPORT;

for (my $i = 0; $i &lt; 10; $i++) {
	$dbhlist[$i] = DBI-&gt;connect("dbi:Teradata:dbc", "dbc", "dbc");
	if (!defined($drh)) { $drh = $dbhlist[$i]-&gt;{Driver}; }
}
my @fa_parms = (\@dbhlist, -1);

for (my $i = 0; $i &lt; $sesscount; $i++) {
	$sthlist[$i] = $dbhlist[$i]-&gt;prepare(
		'USING (col1 INTEGER, col2 CHAR(30), col3 DECIMAL(9,2), col4 DATE) ' .
		'INSERT INTO mytable VALUES(?, ?, ?, ?)', {
		tdat_nowait =&gt; 1,
		tdat_raw =&gt; IndicatorMode
	});
	sysread(IMPORT, $buffer, $len)) {
	$sthlist[$i]-&gt;bind_param(1, $buffer);
	$sthlist[$i]-&gt;execute();
}

while (sysread(IMPORT, $buffer, $len)) {
	$i = $drh-&gt;func(@fa_parms, FirstAvailable);
	$rowcnt = $sthlist[$i]-&gt;func(undef, Realize);
	if (!defined($rowcnt)) {
		print STDERR " ** INSERT failed: " . $sthlist[$i]-&gt;errstr() . "\n";
	}
	$sthlist[$i]-&gt;bind_param(1, $buffer);
	$sthlist[$i]-&gt;execute();
}

while (some statements still active) {
	$i = $drh-&gt;func(@fa_parms, FirstAvailable);
	$rowcnt = $sthlist[$i]-&gt;func(undef, Realize);
	if (!defined($rowcnt)) {
		print STDERR " ** INSERT failed: " . $sthlist[$i]-&gt;errstr() . "\n";
	}
	$sthlist[$i]-&gt;finish();
}
</pre>
</ul><p>

<a name="conform"></a>
<h2>CONFORMANCE</h2><p>

DBD::Teradata 1.20 requires a minimum Perl version of 5.6.0, and a minimum
DBI version of 1.13.<p>

The following DBI functions are not yet supported:
<pre>
DBI->data_sources()
$dbh->prepare_cached()
$sth->table_info()
$dbh->tables()
$dbh->type_info_all()
$dbh->type_info()
</pre>

Also be advised that using either <code>selectall_arrayref()</code> or
<code>fetchall_arrayref()</code> is probably a bad idea unless you know
the number of rows returned is reasonably small.<p>

<a name="platforms"></a>
<h2>SUPPORTED PLATFORMS</h2><p>
This driver have been successfully tested against both Teradata
V2R5.0 and V2R5.1,
running on Windows 2000. Prior versions have also been tested against
V2R3.0 through V2R5.0 on MPRAS.<p>
The following table lists the client platforms (hardware and O/S)
for which successful reported use of this driver have been either
tested or reported.<br>
<table border=1><tr>
	<th align=center>Hardware</th>
	<th align=center>OS</th>
	<th align=center>Perl Version</th>
	<th align=center>DBD::Teradata<br>Version</th>
</tr><tr>
	<td align=center>Intel/AMD PC</td>
	<td align=center>Win98</td>
	<td align=center>5.005<br>(ActivePerl)</td>
	<td align=center>1.12</td>
</tr><tr>
	<td align=center>Intel PC</td>
	<td align=center>WinNT 4.0 SP6</td>
	<td align=center>5.6<br>(ActivePerl)</td>
	<td align=center>1.12</td>
</tr><tr>
	<td align=center>Intel PC</td>
	<td align=center>Linux</td>
	<td align=center>5.??</td>
	<td align=center>1.00</td>
</tr><tr>
	<td align=center>NCR 4XXX (Intel)</td>
	<td align=center>MPRAS</td>
	<td align=center>5.005</td>
	<td align=center>1.10</td>
</tr><tr>
	<td align=center>iMac DV (PowerPC)</td>
	<td align=center>LinuxPPC</td>
	<td align=center>5.005</td>
	<td align=center>1.12</td>
</tr><tr>
	<td align=center>Sun SPARC</td>
	<td align=center>Solaris 4.3</td>
	<td align=center>5.005</td>
	<td align=center>1.10</td>
</tr><tr>
	<td align=center>IBM RS/6000</td>
	<td align=center>AIX</td>
	<td align=center>5.005</td>
	<td align=center>1.10</td>
</tr><tr>
	<td align=center>HP 9000</td>
	<td align=center>HP-UX 11.0</td>
	<td align=center>5.6.0</td>
	<td align=center>1.10</td>
</tr><tr>
	<td align=center>Intel PC</td>
	<td align=center>FreeBSD 3.4-4.2</td>
	<td align=center>5.6.0</td>
	<td align=center>1.10</td>
</table><br>
<p>

<a name="tips"></a>
<h2>TIPS & TRICKS</h2><p>
<ul>
<li>Review the included "test.pl" for examples of using summaries, raw mode, DDL statements, and
non-blocking multisession operations.</li>

<li>Keep in mind that some DDL statements may return errors that are actually acceptable in
some cases, e.g., a "precautionary" DROP TABLE returning a 3807 error if the table doesn't exist.</li>

<li>For optimal performance when bulkloading via non-blocking multisession mode, turn off
AutoCommit and explicitly commit() at periodic intervals.</li>

<li>If you need to re-execute a previously prepared <b>and executed</b> data returning
statement <b><i>before the returned rowset has been completely consumed</i></b>, you <b>must</b>
use <code>sth-&gt;finish()</code> first. The O'Reilly DBI book indicates it isn't essential,
but DBD::Teradata currently needs it to cleanup and cancel the current request.</li>

<li>Similarly, you can't execute new requests on a database handle that has a currently
open and active request on it. Either finish() the current request first, or use an additional
connection to issue the new request.</li>

<li>Be careful about checking error status; Both <code>undef</code> and zero are
interpretted as false, so statements which effect no rows may be interpretted as
errors if you use the simple <code>$sth-&gt;execute || die $sth-&gt;errstr</code> check.
Try <code>defined($sth-&gt;execute) || die $sth-&gt;errstr</code> instead.</li>
<li>Consider setting <b>both</b> <code>PrintError</code> and <code>RaiseError</code>
to zero during <code>DBI-&gt;connect()</code>, and explicitly checking for errors
yourself; otherwise, you may exit unexpectedly or get spurious error messages in the output
when you're just doing a "precautionary" DROP on a non-existant database object.</li>

</ul>
<p>

<a name="refs"></a>
<h2>REFERENCES</h2><p>

<ul>
<li><a href="http://www.presicient.com">Presicient Corp.</a>
<li><a href="http://dbi.perl.org">Official DBI Site</a>
<li><a href="http://www.cpan.org">CPAN</a>
<li><a href="http://www.perl.org">Perl.org</a>
<li><a href="http://www.activestate.com">ActiveState</a> (for Perl software for Windows)
<li><a href="http://www.info.ncr.com">Teradata Online Docs</a>
</ul>

<h2>AUTHOR</h2><p>

<a href="mailto:darnold@presicient.com">Dean Arnold, Presicient Corp.</a><p>

<a name="copy"></a>
<h2>COPYRIGHT</h2><p>

Copyright (c) 2000, Dean Arnold, USA<br>
Copyright (c) 2001-2004, Presicient Corp., USA
<p>

Permission is granted to use this software according to the terms of the
Artistic License, as specified in the Perl README file,
<b>with the exception</b> that commercial redistribution, either
electronic or via physical media, as either a standalone package,
or incorporated into a third party product, requires prior
written approval of the author.
<p>

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<p>

Presicient Corp. reserves the right to provide support for this software
to individual sites under a separate (possibly fee-based)
agreement.<p>

Teradata&reg; is a registered trademark of NCR Corporation.<p>

</body></html>

